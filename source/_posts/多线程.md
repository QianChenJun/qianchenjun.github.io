---
title: 多线程总结
author: 小小千辰
tags:
  - 多线程
  - Java
categories:
  - 千辰的小小笔记
abbrlink: bb4cb507
date: 2021-08-28 18:11:35
updated: 2021-09-03 18:11:35
---



## **程序、进程、线程的理解**

1. 程序(programm)
   * 概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指**一段静态的代码**。
2. 进程(process)
   * 概念：程序的一次执行过程，或是**正在运行的一个程序**。
   * 说明：**进程作为资源分配的单位**，系统在运行时会为每个进程分配不同的内存区域
3. 线程(thread)
   * 概念：进程可进一步细化为线程，是一个程序内部的一条执行路径。
   * 说明：**线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器**(pc)，线程切换的开销小。

![image-20210829202431634](https://cdn.jsdelivr.net/gh/QianChenJun/cloudimage@main/img/202204241759321.png)_进程与线程的图解_

<br>

<br>

<details>
    <summary>补充一个点（关于内存结构的）</summary>
    1. 进程可以细化为多个线程。<br>
	2. 每个线程，拥有自己独立的：栈、程序计数器<br>
	3. 多个线程，共享同一个进程中的结构：方法区、堆。
</details>

![image-20210829202549706](https://cdn.jsdelivr.net/gh/QianChenJun/cloudimage@main/img/202204241759663.png)_内存结构展示_

<br>

<br>

## **并行与并发**

1. 单核CPU与多核CPU的理解
   * 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费。）但是因为CPU时间单元特别短，因此感觉不出来。
   * 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）
   * 一个Java应用程序java.exe，其实至少三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。
2. 并行与并发的理解
   * **并行**：多个CPU同时执行多个任务。比如：多个人同时做不同的事。
   * **并发**：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事

<br>

<br>



## **创建多线程的四种方式**

### 方式一：继承Thread类的方式

1. 创建一个继承于Thread类的子类
2. 重写Thread类的run() --> 将此线程执行的操作声明在run()中
3. 创建Thread类的子类的对象
4. 通过此对象调用start()：①启动当前线程 ② 调用当前线程的run()



> 说明两个问题：
>
> 1. 我们启动一个线程，必须调用start()，不能调用run()的方式启动线程。
> 2. 如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start().



> ~~过于简单，没有代码演示~~

<br>

<br>

### 方式二：实现Runnable接口的方式

1. 创建一个实现了Runnable接口的类
2. 实现类去实现Runnable中的抽象方法：run()
3. 创建实现类的对象
4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
5. 通过Thread类的对象调用start()

<details>
    <summary>两种方式的对比</summary>
    开发中：优先选择：实现Runnable接口的方式<br>
	原因：1. 实现的方式没类的单继承性的局限性<br>
&emsp;&emsp;&emsp;2. 实现的方式更适合来处理多个线程共享数据的情况。<br>
	联系：public class Thread implements Runnable<br>
    相同点：1. 两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。<br>
&emsp;&emsp;&emsp;&emsp;2. 目前两种方式，要想启动线程，都是调用的Thread类中的start()。<br>
</details>

> ~~过于简单，没有代码演示~~

<br>

<br>

<hr>

<div class="danger">
    <blockquote>
        以下两种均为JDK 5.0新增
    </blockquote>
</div>

### 方式三：实现Callable接口。 

> 贴个代码自己悟叭~

```java
//1.创建一个实现Callable的实现类
class NumThread implements Callable{
    //2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            if(i % 2 == 0){
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }
}


public class ThreadNew {
    public static void main(String[] args) {
        //3.创建Callable接口实现类的对象
        NumThread numThread = new NumThread();
        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numThread);
        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
        new Thread(futureTask).start();

        try {
            //6.获取Callable中call方法的返回值
            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
            Object sum = futureTask.get();
            System.out.println("总和为：" + sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

}
```

<div class="warning">
    <blockquote>
        如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？<br>
        &emsp;1. call()可以返回值的。<br>
        &emsp;2. call()可以抛出异常，被外面的操作捕获，获取异常的信息<br>
        &emsp;3. Callable是支持泛型的
    </blockquote>
</div>
<br><br>

### 方式四：使用线程池

```java
class NumberThread implements Runnable{

    @Override
    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

class NumberThread1 implements Runnable{

    @Override
    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 != 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

public class ThreadPool {

    public static void main(String[] args) {
        //1. 提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
        //设置线程池的属性
//        System.out.println(service.getClass());
//        service1.setCorePoolSize(15);
//        service1.setKeepAliveTime();


        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
        service.execute(new NumberThread());//适合适用于Runnable
        service.execute(new NumberThread1());//适合适用于Runnable

//        service.submit(Callable callable);//适合使用于Callable
        //3.关闭连接池
        service.shutdown();
    }

}
```

<details>
    <summary>好处</summary>
    <ol>
        <li>提高响应速度（减少了创建新线程的时间）</li>
        <li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
        <li>便于线程管理</ol>
    </ol>
</details>

<br>

<br>



## **Thread类中的常用的方法**

1. `start()`:启动当前线程；调用当前线程的`run()`
2. `run()`: 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中
3. `currentThread()`:静态方法，返回执行当前代码的线程
4. `getName()`:获取当前线程的名字
5. `setName()`:设置当前线程的名字
6. `yield()`:释放当前cpu的执行权
7. `join()`:在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。
8. `stop():`**已过时**。当执行此方法时，强制结束当前线程。
9. `sleep(long millitime)`:让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。
10. `isAlive()`:判断当前线程是否存活

<br>

<br>

### 线程的优先级

```
1.
	MAX_PRIORITY：10
    MIN _PRIORITY：1
    NORM_PRIORITY：5  -->默认优先级
2.如何获取和设置当前线程的优先级：
    getPriority():获取线程的优先级
    setPriority(int p):设置线程的优先级
```

<div class="warning">
    <blockquote>
说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。
    </blockquote>
</div>

<br>

<br>

### 线程的分类

1. **守护线程**
2. **用户线程**

<br>

<br>



## **Thread的生命周期**

![image-20210903195424511](https://cdn.jsdelivr.net/gh/QianChenJun/cloudimage@main/img/202204241759798.png)_线程的生命周期_

<br>

说明：

1. 生命周期关注两个概念：状态、相应的方法

2. 关注：

      1. 状态a-->状态b:哪些方法执行了（回调方法）

      2. 某个方法主动调用：状态a-->状态b

3. 阻塞：临时状态，不可以作为最终状态
   死亡：最终状态。

<br>
<br>

## **线程的同步机制**

> 背景

> 例子：创建个窗口卖票，总票数为100张.使用实现Runnable接口的方式
>
> 1. 问题：卖票过程中，出现了重票、错票 -->出现了线程的安全问题
> 2. 问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。
> 3. 如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。

<br>
<br>

### **Java的解决方案：同步机制**

在Java中，我们通过同步机制，来解决线程的安全问题。

#### 方式一：同步代码块

```java
synchronized(同步监视器){
      // 需要被同步的代码
}
```

说明：

1. 操作共享数据的代码，即为需要被同步的代码。  -->不能包含代码多了，也不能包含代码少了。
2. **共享数据**：多个线程共同操作的变量。比如：ticket就是共享数据。
3. **同步监视器**，俗称：锁。任何一个类的对象，都可以充当锁。
4. **要求：多个线程必须共用一把锁。**

<details>
    <summary>补充</summary>
    <ol>
        <li>在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</li>
        <li>在继承Thread类创建多线程的方式中，<strong>慎用</strong>this充当同步监视器，考虑使用当前类充当同步监视器。</li>
    </ol>
</details>

```java
synchronized (this) {
                if (ticket > 0) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + ":剩余票: " + ticket);
                    ticket--;
                } else {
                    break;
                }
            }

```

<br>

#### 方式二：同步方法

如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。

关于同步方法的总结：

1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
2. 1. 非静态的同步方法，同步监视器是：this
   2. 静态的同步方法，同步监视器是：当前类本身

```java
private static synchronized void show() {  // 同步监视器：类名.class
        if (ticket > 0) {
            System.out.println(Thread.currentThread().getName() + "：，卖票，票号为：" + ticket);
            ticket--;
        }
    }
<br>
```

#### 方式三：Lock锁  --- JDK5.0新增

```java
class Window implements Runnable {

    private int ticket = 100; // 车票
    // 1. 实例化ReentrantLock对象
    private ReentrantLock lock = new ReentrantLock();

    @Override
    public void run() {
        try {

            // 2. 调用lock方法
            lock.lock();

            while (true) {
                if (ticket > 0) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    System.out.println(Thread.currentThread().getName() + "售票，票号为：" + ticket);
                    ticket--;
                } else {
                    break;
                }
            }
        } finally {
            // 3. 解锁
            lock.unlock();
        }
    }
}

public class LockTest {
    public static void main(String[] args) {
        Window w = new Window();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口一");
        t2.setName("窗口二");
        t3.setName("窗口三");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

<br>

<div class="success">
    <blockquote>
        使用的优先顺序：Lock ---> 同步代码块（已经进入了方法体，分配了相应资源 ) ---> 同步方法（在方法体之外)
    </blockquote>
</div>

<br>

#### 利弊

1. 同步的方式，解决了线程的安全问题。---好处
2. 操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。

<br>

### 线程安全的单例模式(懒汉式)

> 使用同步机制将单例模式中的懒汉式改写为线程安全的。

```java
class Bank{

    private Bank(){}

    private static Bank instance = null;

    public static Bank getInstance(){
        //方式一：效率稍差
//        synchronized (Bank.class) {
//            if(instance == null){
//
//                instance = new Bank();
//            }
//            return instance;
//        }
        //方式二：效率更高
        if(instance == null){

            synchronized (Bank.class) {
                if(instance == null){

                    instance = new Bank();
                }

            }
        }
        return instance;
    }

}
```

<br>

### 死锁问题

1. 死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
2. 说明：
   1. 出现死锁后，不会出现异常，不会出现提示，只是所的线程都处于阻塞状态，无法继续
   2. 我们使用同步时，要避免出现死锁。

```java
// 死锁案例
class A {
    public synchronized void foo(B b) {
        System.out.println("当前线程名: " + Thread.currentThread().getName()
                + " 进入了A实例的foo方法"); // ①
        try {
            Thread.sleep(200);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        System.out.println("当前线程名: " + Thread.currentThread().getName()
                + " 企图调用B实例的last方法"); // ③
        b.last();
    }

    public synchronized void last() {
        System.out.println("进入了A类的last方法内部");
    }
}

class B {
    public synchronized void bar(A a) {
        System.out.println("当前线程名: " + Thread.currentThread().getName()
                + " 进入了B实例的bar方法"); // ②
        try {
            Thread.sleep(200);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        System.out.println("当前线程名: " + Thread.currentThread().getName()
                + " 企图调用A实例的last方法"); // ④
        a.last();
    }

    public synchronized void last() {
        System.out.println("进入了B类的last方法内部");
    }
}

public class DeadLock implements Runnable {
    A a = new A();
    B b = new B();

    public void init() {
        Thread.currentThread().setName("主线程");
        // 调用a对象的foo方法
        a.foo(b);
        System.out.println("进入了主线程之后");
    }

    public void run() {
        Thread.currentThread().setName("副线程");
        // 调用b对象的bar方法
        b.bar(a);
        System.out.println("进入了副线程之后");
    }

    public static void main(String[] args) {
        DeadLock dl = new DeadLock();
        new Thread(dl).start();
        dl.init();
    }
}

```

![image-20210903204843857](https://cdn.jsdelivr.net/gh/QianChenJun/cloudimage@main/img/202204241759972.png)_线程死锁，程序永远不会停止_

<br>

<br>



## **线程通信**

1. 线程通信涉及到的三个方法：
   1. `wait()`:一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。
   2. `notify()`:一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。
   3. `notifyAll()`:一旦执行此方法，就会唤醒所有被wait的线程。
2. 说明：
   1. `wait()，notify()，notifyAll()`三个方法必须使用在同步代码块或同步方法中。
   2. `wait()，notify()，notifyAll()`三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现**IllegalMonitorStateException**异常
   3. `wait()，notify()，notifyAll()`三个方法是定义在java.lang.Object类中。

<br>

> 线程一和线程二交替打印1~100以内的数字

```java
class Number implements Runnable {

    private int number = 1; // 数字
    private Object o = new Object();


    @Override
    public void run() {

        while (true) {
            synchronized (o) {
                //
                o.notify();
                if (number <= 100) {

                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    System.out.println(Thread.currentThread().getName() + ":" + number);
                    number++;

                    try {
                        // 使得调用如下wait()方法的线程进入阻塞状态
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                } else {
                    break;
                }
            }
        }
    }
}

public class CommunicationTest {
    public static void main(String[] args) {
        Number n = new Number();

        Thread t1 = new Thread(n);
        Thread t2 = new Thread(n);

        t1.setName("线程一");
        t2.setName("线程二");

        t1.start();
        t2.start();
    }
}
```



<br>

> 释放锁的操作：

![image-20210903202516835](https://cdn.jsdelivr.net/gh/QianChenJun/cloudimage@main/img/202204241759868.png)

<br>

> 不会释放锁的操作：

![image-20210903202531489](https://cdn.jsdelivr.net/gh/QianChenJun/cloudimage@main/img/202204241800356.png)

<br><br>

## **经典线程问题（生产者消费者）**

```java
// 店员
class Clerk {

    // 产品数量
    private int productCount = 0;

    // 生产产品
    public synchronized void produceProduct() {
        if (productCount < 20) {
            productCount++;
            System.out.println(Thread.currentThread().getName() + "开始生产第" + productCount + "个产品");
            notify();
        } else {
            // 等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    // 消费产品
    public synchronized void consumeProduct() {
        if (productCount > 0) {
            System.out.println(Thread.currentThread().getName() + "开始消费第" + productCount + "个产品");
            productCount--;
            notify();
        } else {
            // 等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

// 生产者
class Producer extends Thread {
    private Clerk clerk;

    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "开始生产产品....");

        while (true) {

            try {
                sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            clerk.produceProduct();
        }
    }
}

// 消费者
class Consumer extends Thread {
    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "开始消费产品....");

        while (true) {

            try {
                sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            clerk.consumeProduct();
        }
    }
}

public class ProductTest {
    public static void main(String[] args) {
        Clerk clerk = new Clerk();

        Producer p1 = new Producer(clerk);
        p1.setName("生产者1");

        Consumer c1 = new Consumer(clerk);
        c1.setName("消费者1");

        p1.start();
        c1.start();
    }
}
```

<br>
<br>

## 面试题总结

<details>
	<summary>synchronized 与 Lock的异同？</summary>
    <ul>
        <li>相同：二者都可以解决线程安全问题</li>
        <li>不同：
            <ol>
            	<li>synchronized机制在执行完相应的同步代码以后，自动的释放同步监视</li>
                <li>Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）</li>
            </ol>
        </li>
    </ul>
</details>

<details>
	<summary>写一个线程安全的单例模式</summary>
    <ul>
        <li>饿汉式</li>
        <li>或者前文提供的线程安全的懒汉式</li>
    </ul>
</details>

<details>
	<summary>sleep() 和 wait()的异同？</summary>
    <ul>
        <li>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</li>
        <li>不同点：
        	<ol>
            	<li>两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li>
                <li>调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</li>
                <li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。
</li>
            </ol>
        </li>
    </ul>
</details>
****
